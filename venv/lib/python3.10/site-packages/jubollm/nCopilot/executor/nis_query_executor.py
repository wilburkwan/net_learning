import logging
from bson import ObjectId
from datetime import datetime, timedelta
from linkinpark.lib.common.mongo_connector import MongodbReadOnly

from jubollm.nCopilot.executor.base_executor import BaseExecutor


class NisQueryExecutor(BaseExecutor):
    def __init__(self, json_schema):
        table = json_schema.get("interface_type")
        columns = json_schema.get("retrieve", [])
        conditions = json_schema.get("conditions", {})
        name = json_schema.get("patientName")

        super().__init__(table, columns, conditions, name)
        self.connection = None
        self.mongo = MongodbReadOnly(env="dev")

    def construct_query(self, patient_id):
        query = {"patient": patient_id}
        projection = {field: 1 for field in self.columns}
        sort_fields = []
        limit = None
        start_date = None

        # Check for duration condition and update the query
        if self.conditions and self.conditions.get("duration"):
            end_date = datetime.now()
            start_date = end_date - timedelta(days=int(self.conditions["duration"]))
            query["createdDate"] = {"$gte": start_date, "$lte": end_date}
            logging.info(f"Time range: start_date = {start_date}, end_date = {end_date}")

        logging.info(f"Query: {query}")

        # Check for sortby condition and update the sort_fields list
        if self.conditions and self.conditions.get("sortby"):
            sort_fields = [(key, -1 if value.lower() == "descending" else 1) for key, value in self.conditions["sortby"].items()]
            logging.info(f"Sort fields: {sort_fields}")

        # Check for limit condition and set the limit variable
        if self.conditions and self.conditions.get("limit"):
            limit = int(self.conditions["limit"])
            limit = 10 if limit > 10 else limit
            logging.info(f"Limit: {limit}")

        return query, projection, sort_fields, limit, start_date

    def execute_query(self, collection, query, projection, sort_fields, limit):
        cursor = collection.find(query, projection)

        if sort_fields:
            cursor = cursor.sort(sort_fields)
        
        if limit:
            cursor = cursor.limit(limit)

        results = [doc for doc in cursor if all(field in doc for field in self.columns)]
        logging.info(f"Results: {results}")

        return results

    def construct_link(self, patient_id_str, start_date, base_url):
        if self.conditions and self.conditions.get("duration"):
            link_str = f"{base_url}/{patient_id_str}?start={str(start_date)[:10]}"
        else:
            link_str = f"{base_url}/{patient_id_str}"
        link = {"link": link_str}

        logging.info(f"Link: {link}")
        return link

    def execute(self, collection_name, patient_id_str):
        patient_id = ObjectId(patient_id_str)

        if collection_name == 'patients_info':
            patients_info_query = {"_id": patient_id}
            logging.info(f"MongoDB Query: {patients_info_query}, Projection: {self.columns}")
            result = self.mongo['patients'].find_one(patients_info_query, {field: 1 for field in self.columns})

            results = [result] if result else []
            link = self.construct_link(patient_id_str, None, "https://smc.jubo.health/MyPatient")
        else:
            vitalsigns_query, projection, sort_fields, limit, start_date = self.construct_query(patient_id)
            results = self.execute_query(self.mongo['vitalsigns'], vitalsigns_query, projection, sort_fields, limit)
            link = self.construct_link(patient_id_str, start_date, "https://smc.jubo.health/VitalSign/patient")
        
        results.append(link)
        return results
